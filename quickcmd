#!/usr/bin/env python
# -*- coding: utf-8 -*-

import curses
import subprocess
import os
import os.path
import sys
import argparse

class AliasNotFound(Exception):
    def __init__(self, alias):
        Exception.__init__(self, 'Alias \'' + alias + '\' not found')

class Line:
    view = False # False: alias, True: command
    selectable = False
    bold = False

class Empty(Line):
    def __str__(self):
        return ''

class Command(Line):
    selectable = True

    def __init__(self, alias, cmd):
        self.alias = alias
        self.cmd = cmd

    def __str__(self):
        return [self.alias, self.cmd][self.view]
            
class Comment(Line):
    bold = True

    def __init__(self, text):
        self.text = text

    def __str__(self):
        return self.text

class Quickcmd:

    def __init__(self, stdscr=None):
        self.config_path = ''
        self.view = 0
        self.selection = -1
        self.items = []
        self.stdscr = stdscr
        self.command = ''
        self.selectables = []
        self.first_letters = []

        self.setup_config()
        self.read_file()

    def gui(self):
        self.setup_curses()
        self.display()
        self.wait_for_user()

    def setup_config(self):
        self.config_path = os.path.expanduser('~' + os.path.sep + '.quickcmd')
        if not os.path.isfile(self.config_path):
            self.config_path = 'config'

    def disable_curses(self):
        self.stdscr.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()

    def enable_curses(self):
        self.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        self.stdscr.keypad(1)
        try:
            curses.start_color()
        except:
            pass

        self.setup_curses()

    def setup_curses(self):
        curses.curs_set(0)

    def wait_for_user(self):

        selection2group = lambda selection: ([selection-g>=0 for g in self.groups] + [False]).index(False)-1
        
        while(True):

            selected = self.selection >= 0
            k = self.stdscr.getkey()

            if selected and k == '\n': # RETURN
                self.command = self.items[self.selection].cmd
                break
            elif selected and k == 'KEY_UP':
                i = self.selectables.index(self.selection)
                self.selection = self.selectables[max(i-1, 0)]
                self.display()
            elif selected and k == 'KEY_DOWN':
                i = self.selectables.index(self.selection)
                self.selection = self.selectables[min(i+1, len(self.selectables)-1)]
                self.display()
            elif selected and k in ['KEY_PPAGE', 'KEY_SR']: # PAGE_UP of SHIFT+UP_ARROW
                i = selection2group(self.selection)
                self.selection = self.groups[max(i-1, 0)]
                self.display()
            elif selected and k in ['KEY_NPAGE', 'KEY_SF']: # PAGE_DOWN of SHIFT+DOWN_ARROW
                i = selection2group(self.selection)
                self.selection = self.groups[min(i+1, len(self.groups)-1)]
                self.display()
            elif k == 'KEY_LEFT':
                pass
            elif k == 'KEY_RIGHT':
                pass
            elif k == 'KEY_BACKSPACE':
                pass
            elif k == '\t':
                self.disable_curses()
                os.system('vi +' + str(self.selection+1) + ' ' + self.config_path)
                self.enable_curses()
                self.read_file()
                self.display()
            elif k == ' ': # SPACE
                Line.view = not Line.view
                self.display()
            elif k == 'kUP5': # CTRL+UP_ARROW
                pass
            elif k == 'kDN5': # CTRL+DOWN_ARROW
                pass
            elif selected and k in [chr(x) for x in range(ord('a'), ord('z')+1)]: # a-z
                i = (self.selectables.index(self.selection) + 1) % len(self.selectables)
                first_letters = self.first_letters[i:] + self.first_letters[:i]

                try:
                    f = (first_letters.index(k) + i) % len(first_letters)
                except ValueError: # letter not found
                    f = -1

                if f >= 0:
                    self.selection = self.selectables[f]
                    self.display()

    def read_file(self):
        self.items = []
        self.selectables = []
        self.groups = []
        self.first_letters = []
        self.selection = -1

        if os.path.isfile(self.config_path):
            f_config = open(self.config_path, 'r')
            for raw_line in f_config:
                line = raw_line.strip()
                if len(line):
                    if line[0] == '#':
                        self.items.append(Comment(line[1:]))
                    else:
                        sep = line.find(' ')
                        if sep < 0:
                            alias = line
                            command = line
                        else:
                            alias = line[:sep].strip()
                            command = line[sep:].strip()

                        self.items.append(Command(alias, command))
                else:
                    self.items.append(Empty())

            f_config.close()

            self.selectables = [i for (i, item) in enumerate(self.items) if item.selectable]
            self.groups = [x for x,y in zip(self.selectables, [-2] + self.selectables[:-1]) if x-y>1]
            self.first_letters = [self.items[i].alias[0].lower() for i in self.selectables]

        if len(self.selectables):
            self.selection = self.selectables[0]

    def display(self):
        self.stdscr.clear()
        self.stdscr.refresh()

        for (i, item) in enumerate(self.items):
            if i == self.selection:
                self.stdscr.attron(curses.A_STANDOUT)

            if item.bold:
                self.stdscr.attron(curses.A_BOLD)
            
            self.stdscr.addstr(i, 0, str(item))
            
            self.stdscr.attroff(curses.A_STANDOUT)
            self.stdscr.attroff(curses.A_BOLD)

    def execute(self, alias):
        try:
            selectable_items = [item for item in self.items if item.selectable]
            i = [item.alias for item in selectable_items].index(alias)
        except ValueError, e:
            raise AliasNotFound(alias)

        self.command = selectable_items[i].cmd

command = ''
def gui(stdscr):
    qc = Quickcmd(stdscr)
    qc.gui()
    global command
    command = qc.command

def cui(alias):
    qc = Quickcmd()
    qc.execute(alias)
    global command
    command = qc.command

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('alias', nargs='?', help='an integer for the accumulator')
    args = parser.parse_args()

    try:
        if args.alias == None:
            curses.wrapper(gui)
        else:
            cui(args.alias)

        subprocess.call(command, shell=True)

    except KeyboardInterrupt: # CTRL+C
        pass

    except Exception, e:
        print 'ERROR: ' + str(e)
        exit(1)


