#!/usr/bin/env python
# -*- coding: utf-8 -*-

import curses
import subprocess
import os
import os.path
import sys
import argparse

class AliasNotFound(Exception):
    def __init__(self, alias):
        Exception.__init__(self, 'Alias \'' + alias + '\' not found')

class ConfigItem:
    """Base class for the items which can be met in config file
    """
    view = False # defines current view; False: alias, True: command
    selectable = False # says whether item is selectable in gui or not
    bold = False # says whether item should be displayed in bold or not

class Empty(ConfigItem):
    """Represents empty line in the config file
    """
    def __str__(self):
        return ''

class Command(ConfigItem):
    """Represents alias & command in the config file
    """
    selectable = True

    def __init__(self, alias, cmd, line_number):
        self.alias = alias
        self.cmd = cmd
        self.line_number = line_number # starting from 1

    def __str__(self):
        return [self.alias, self.cmd][self.view]
            
class Comment(ConfigItem):
    """Represents displayable comment in the config file
    """
    bold = True

    def __init__(self, text):
        self.text = text

    def __str__(self):
        return self.text

class Quickcmd:
    """Engine, manages app data and gui
    """
    def __init__(self):
        self.config_path = ''     # path to the config file
        self.selection = -1       # currently selected item
        self.items = []           # all items from config file
        self.stdscr = None        # current curses screen
        self.command = ''         # command which at the end should be spawn whith this application
        self.selectables = []     # indices of the items whcih are selectable
        self.first_letters = []   # first letter of each alias
        self.action = 0           # action to be taken at the exit

        self.config_path = os.path.expanduser('~' + os.path.sep + '.quickcmd')
        self.read_config()

    def display_gui(self):
        """Displays curses based GUI
        """
        self.enable_curses()
        self.setup_curses()
        self.update_gui()
        try:
            self.wait_for_user()
        except KeyboardInterrupt: # CTRL+C
            pass
        finally:
            self.disable_curses()

    def enable_curses(self):
        """Enables curses library to display GUI.
           This code is based on curses.wrapper code
        """
        self.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        self.stdscr.keypad(1)
        try:
            curses.start_color()
        except:
            pass

        self.setup_curses()

    def disable_curses(self):
        """Cleans up after curses, so returning to the console is save.
           This code is based on curses.wrapper code
        """
        self.stdscr.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()

    def setup_curses(self):
        """Does application specyfic configuration of curses
        """
        curses.curs_set(0)

    def wait_for_user(self):
        """Interacts with the user when GUI is displayed
        """
        selection2group = lambda selection: ([selection-g>=0 for g in self.groups] + [False]).index(False)-1
        
        while(True):

            selected = self.selection >= 0
            k = self.stdscr.getkey()

            if k == 'q':
                break
            elif selected and k == '\n': # RETURN
                # Spawns the app with the command selected by user
                self.command = self.items[self.selection].cmd
                self.action = 1
                break
            elif k == 'p':
                self.command = self.items[self.selection].cmd
                self.action = 2
                break
            elif k == 't':
                self.command = self.items[self.selection].cmd
                self.action = 3
                break
            elif selected and k in ['KEY_UP', 'k']: # ARROW_UP or K
                # Moves selection up by one item
                i = self.selectables.index(self.selection)
                self.selection = self.selectables[max(i-1, 0)]
                self.update_gui()
            elif selected and k in ['KEY_DOWN', 'j']: # ARROW_DOWN or J
                # Moves selection down by one item
                i = self.selectables.index(self.selection)
                self.selection = self.selectables[min(i+1, len(self.selectables)-1)]
                self.update_gui()
            elif selected and k in ['KEY_PPAGE', 'KEY_SR']: # PAGE_UP of SHIFT+ARROW_UP
                # Moves selection up by one group
                i = selection2group(self.selection)
                self.selection = self.groups[max(i-1, 0)]
                self.update_gui()
            elif selected and k in ['KEY_NPAGE', 'KEY_SF']: # PAGE_DOWN of SHIFT+ARROW_DOWN
                # Moves selection down by one group
                i = selection2group(self.selection)
                self.selection = self.groups[min(i+1, len(self.groups)-1)]
                self.update_gui()
            elif k == 'e':
                # Opens config file in VI for editing
                self.disable_curses()
                os.system('vi +' + str(self.items[self.selection].line_number) + ' ' + self.config_path)
                self.enable_curses()
                self.read_config()
                self.update_gui()
            elif k == '\t': # TAB
                # Switches between alias/command views
                ConfigItem.view = not ConfigItem.view
                self.update_gui()
            elif k == 'KEY_LEFT':
                # For future use
                pass
            elif k == 'KEY_RIGHT':
                # For future use
                pass
            elif k == 'KEY_BACKSPACE':
                # For future use
                pass
            elif k == 'kUP5': # CTRL+UP_ARROW
                # For future use
                pass
            elif k == 'kDN5': # CTRL+DOWN_ARROW
                # For future use
                pass

    def read_config(self):
        """Reads config file
        """
        self.items = []
        self.selectables = []
        self.groups = []
        self.first_letters = []
        self.selection = -1

        displayable_content = False
        if os.path.isfile(self.config_path):
            f_config = open(self.config_path, 'r')
            line_number = 0
            for raw_line in f_config:
                line_number += 1
                line = raw_line.strip()
                if line:
                    if line[0] == '#':
                        if len(line)>1 and line[1] == '#':
                            # Non-displayable comment
                            pass
                        else:
                            # Displayable comment
                            displayable_content = True
                            self.items.append(Comment(line[1:]))
                    else:
                        displayable_content = True
                        sep = line.find(' ')
                        if sep < 0:
                            # Alias is same as the command
                            alias = line
                            command = line
                        else:
                            # New alias & command pair
                            alias = line[:sep].strip()
                            command = line[sep:].strip()

                        self.items.append(Command(alias, command, line_number))
                else:
                    # Empty line
                    if displayable_content: # Ignore empty lines before actual content
                        self.items.append(Empty())

            f_config.close()

            self.selectables = [i for (i, item) in enumerate(self.items) if item.selectable]
            self.groups = [x for x,y in zip(self.selectables, [-2] + self.selectables[:-1]) if x-y>1]
            self.first_letters = [self.items[i].alias[0].lower() for i in self.selectables]

        if len(self.selectables):
            self.selection = self.selectables[0]

    def update_gui(self):
        """Updates GUI with displayable items form config file
        """
        self.stdscr.clear()

        for (i, item) in enumerate(self.items):
            if i == self.selection:
                self.stdscr.attron(curses.A_STANDOUT) # Highlighting ON

            if item.bold:
                self.stdscr.attron(curses.A_BOLD)     # Bold ON
            
            self.stdscr.addstr(i, 0, str(item))
            
            self.stdscr.attroff(curses.A_STANDOUT)    # Highlighting OFF
            self.stdscr.attroff(curses.A_BOLD)        # Bold OFF

        self.stdscr.refresh()

    def find_cmd(self, alias):
        """Searches for the command by it's alias
        """
        try:
            selectable_items = [item for item in self.items if item.selectable]
            i = [item.alias for item in selectable_items].index(alias)
        except ValueError, e:
            raise AliasNotFound(alias)

        self.command = selectable_items[i].cmd

    def list_aliases(self):
        """Prints all the aliases from the config file
        """
        aliases = list(set([item.alias for item in self.items if item.selectable])) # set does unique()
        aliases.sort()
        for alias in aliases:
            print alias

    def finalize(self):
        if self.command:
            action = [self.action_ignore, self.action_execute, self.action_print, self.action_type][self.action]
            action(self.command)

    def action_ignore(self, cmd):
        pass

    def action_execute(self, cmd):
        subprocess.call(qc.command, shell=True)

    def action_print(self, cmd):
        print cmd

    def action_type(self, cmd):
        text = cmd.replace('"', '\\"')
        ppid = os.getpid()
        cpid = os.fork()

        if cpid == 0: # Child            
            try:
                while(True): # Wait for parent to finish and release command prompt
                    os.kill(ppid, 0)
            except OSError, e:
                pass

            os.system('echo str "' + text + '" | xte')


if __name__ == "__main__":

    description = \
    """
    Gives quick access and allows to execute commands defined in advance.
    Each command can have own alias. Set of commands and aliases is defined
    in .quickcmd file in your home directory.

    Key bindings:
    --------------
    CTRL+C                        - close application
    RETURN                        - close application and execute selected command
    ARROW_UP                      - select previous command
    ARROW_DOWN                    - select next command
    PAGE_UP or SHIFT+ARROW_UP     - move selection to the previous group
    PAGE_DOWN or SHIFT+ARROW_DOWN - move selection to the next group
    TAB                           - edit configuration file
    SPACE                         - switch view between aliases and commands
    a-z                           - move selestion to the next command, alias of
                                    witch begins with the given letter
    """

    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('alias', nargs='?', help='Exexute command specyfied by alias')
    parser.add_argument('--list', '-l', action='store_true', help='List available aliases')
    args = parser.parse_args()

    try:
        qc = Quickcmd()
        if args.list:
            qc.list_aliases()
        else:
            if args.alias == None:
                qc.display_gui()
            else:
                qc.find_cmd(args.alias)

            qc.finalize()

    except Exception, e:
        print 'ERROR: ' + str(e)
        exit(1)


