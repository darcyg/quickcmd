#!/usr/bin/env python
# -*- coding: utf-8 -*-

import curses
import subprocess
import os
from os.path import expanduser

class Line:
    view = False # False: alias, True: command
    selectable = False
    bold = False

class Empty(Line):
    def __str__(self):
        return ''

class Command(Line):
    selectable = True

    def __init__(self, alias, cmd):
        self.alias = alias
        self.cmd = cmd

    def __str__(self):
        return [self.alias, self.cmd][self.view]
            
class Comment(Line):
    bold = True

    def __init__(self, text):
        self.text = text

    def __str__(self):
        return self.text

class Quickcmd:

    def __init__(self, stdscr):
        self.config_path = ''
        self.view = 0
        self.selection = -1
        self.items = []
        self.stdscr = stdscr
        self.command = ''
        self.selectables = []

        self.setup_config()
        self.setup_curses()
        self.read_file()
        self.display()
        self.wait_for_user()

    def setup_config(self):
        self.config_path = os.path.expanduser('~' + os.path.sep + '.quickcmd')
        if not os.path.isfile(self.config_path):
            self.config_path = 'config'

    def disable_curses(self):
        self.stdscr.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()

    def enable_curses(self):
        self.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        self.stdscr.keypad(1)
        try:
            curses.start_color()
        except:
            pass

        self.setup_curses()

    def setup_curses(self):
        curses.curs_set(0)

    def wait_for_user(self):

        selection2group = lambda selection: ([selection-g>=0 for g in self.groups] + [False]).index(False)-1

        while(True):
            k = self.stdscr.getkey()
            if k == '\n': # RETURN
                self.command = self.items[self.selection].cmd
                break
            elif k == 'KEY_UP':
                i = self.selectables.index(self.selection)
                self.selection = self.selectables[max(i-1, 0)]
                self.display()
            elif k == 'KEY_DOWN':
                i = self.selectables.index(self.selection)
                self.selection = self.selectables[min(i+1, len(self.selectables)-1)]
                self.display()
            elif k in ['KEY_PPAGE', 'KEY_SR']: # PAGE_UP of SHIFT + UP_ARROW
                i = selection2group(self.selection)
                self.selection = self.groups[max(i-1, 0)]
                self.display()
            elif k in ['KEY_NPAGE', 'KEY_SF']: # PAGE_DOWN of SHIFT + DOWN_ARROW
                i = selection2group(self.selection)
                self.selection = self.groups[min(i+1, len(self.groups)-1)]
                self.display()
            elif k == 'KEY_LEFT':
                pass
            elif k == 'KEY_RIGHT':
                pass
            elif k == 'e':
                self.disable_curses()
                os.system('vi +' + str(self.selection+1) + ' ' + self.config_path)
                self.enable_curses()
                self.read_file()
                self.display()
            elif k == ' ': # SPACE
                pass
            elif k == '\t': # TAB
                Line.view = not Line.view
                self.display()
            elif k == 'h':
                pass
            elif k == 'q':
                break
            elif k == 'kUP5': # CTRL + UP_ARROW
                pass
            elif k == 'kDN5': # CTRL + DOWN_ARROW
                pass


    def read_file(self):
        self.items = []
        f_config = open(self.config_path, 'r')
        for raw_line in f_config:
            line = raw_line.strip()
            if len(line):
                if line[0] == '#':
                    self.items.append(Comment(line[1:]))
                else:
                    sep = line.find(' ')
                    if sep < 0:
                        alias = line
                        command = line
                    else:
                        alias = line[:sep].strip()
                        command = line[sep:].strip()

                    self.items.append(Command(alias, command))
            else:
                self.items.append(Empty())

        f_config.close()

        self.selectables = [i for (i, item) in enumerate(self.items) if item.selectable]
        self.groups = [x for x,y in zip(self.selectables, [-2] + self.selectables[:-1]) if x-y>1]

        if len(self.selectables):
            self.selection = self.selectables[0]
        else:
            self.selection = -1

    def display(self):
        self.stdscr.clear()
        self.stdscr.refresh()

        for (i, item) in enumerate(self.items):
            if i == self.selection:
                self.stdscr.attron(curses.A_STANDOUT)

            if item.bold:
                self.stdscr.attron(curses.A_BOLD)
            
            self.stdscr.addstr(i, 0, str(item))
            
            self.stdscr.attroff(curses.A_STANDOUT)
            self.stdscr.attroff(curses.A_BOLD)

command = ''
def main(stdscr):
    qc = Quickcmd(stdscr)
    global command
    command = qc.command

if __name__ == "__main__":    
    curses.wrapper(main)
    subprocess.call(command, shell=True)

