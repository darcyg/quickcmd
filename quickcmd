#!/usr/bin/env python
# -*- coding: utf-8 -*-

import curses
import subprocess
import os
import os.path
import sys
import argparse

class AliasNotFound(Exception):
    def __init__(self, alias):
        Exception.__init__(self, 'Alias \'' + alias + '\' not found')

class ConfigItem:
    """Base class for the items which can be met in config file
    """
    view = False # defines current view; False: alias, True: command
    selectable = False # says whether item is selectable in gui or not
    bold = False # says whether item should be displayed in bold or not

class Empty(ConfigItem):
    """Represents empty line in the config file
    """
    def __str__(self):
        return ''

class Command(ConfigItem):
    """Represents alias & command in the config file
    """
    selectable = True

    def __init__(self, alias, cmd):
        self.alias = alias
        self.cmd = cmd

    def __str__(self):
        return [self.alias, self.cmd][self.view]
            
class Comment(ConfigItem):
    """Represents displayable comment in the config file
    """
    bold = True

    def __init__(self, text):
        self.text = text

    def __str__(self):
        return self.text

class Quickcmd:
    """Engine, manages app data and gui
    """
    def __init__(self):
        self.config_path = ''     # path to the config file
        self.selection = -1       # currently selected item
        self.items = []           # all items from config file
        self.stdscr = None        # current curses screen
        self.command = ''         # command which at the end should be spawn whith this application
        self.selectables = []     # indices of the items whcih are selectable
        self.first_letters = []   # first letter of each alias

        self.config_path = os.path.expanduser('~' + os.path.sep + '.quickcmd')
        self.read_config()

    def display_gui(self):
        """Displays curses based GUI
        """
        self.enable_curses()
        self.setup_curses()
        self.update_gui()
        try:
            self.wait_for_user()
        except KeyboardInterrupt: # CTRL+C
            pass
        finally:
            self.disable_curses()

    def enable_curses(self):
        """Enables curses library to display GUI.
           This code is based on curses.wrapper code
        """
        self.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        self.stdscr.keypad(1)
        try:
            curses.start_color()
        except:
            pass

        self.setup_curses()

    def disable_curses(self):
        """Cleans up after curses, so returning to the console is save.
           This code is based on curses.wrapper code
        """
        self.stdscr.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()

    def setup_curses(self):
        """Does application specyfic configuration of curses
        """
        curses.curs_set(0)

    def wait_for_user(self):
        """Interacts with the user when GUI is displayed
        """
        selection2group = lambda selection: ([selection-g>=0 for g in self.groups] + [False]).index(False)-1
        
        while(True):

            selected = self.selection >= 0
            k = self.stdscr.getkey()

            if selected and k == '\n': # RETURN
                # Spawns the app with the command selected by user
                self.command = self.items[self.selection].cmd
                break
            elif selected and k == 'KEY_UP': # ARROW_UP
                # Moves selection up by one item
                i = self.selectables.index(self.selection)
                self.selection = self.selectables[max(i-1, 0)]
                self.update_gui()
            elif selected and k == 'KEY_DOWN': # ARROW_DOWN
                # Moves selection down by one item
                i = self.selectables.index(self.selection)
                self.selection = self.selectables[min(i+1, len(self.selectables)-1)]
                self.update_gui()
            elif selected and k in ['KEY_PPAGE', 'KEY_SR']: # PAGE_UP of SHIFT+ARROW_UP
                # Moves selection up by one group
                i = selection2group(self.selection)
                self.selection = self.groups[max(i-1, 0)]
                self.update_gui()
            elif selected and k in ['KEY_NPAGE', 'KEY_SF']: # PAGE_DOWN of SHIFT+ARROW_DOWN
                # Moves selection down by one group
                i = selection2group(self.selection)
                self.selection = self.groups[min(i+1, len(self.groups)-1)]
                self.update_gui()
            elif k == '\t': # TAB
                # Opens config file in VI for editing
                self.disable_curses()
                os.system('vi +' + str(self.selection+1) + ' ' + self.config_path)
                self.enable_curses()
                self.read_config()
                self.update_gui()
            elif k == ' ': # SPACE
                # Switches between alias/command views
                ConfigItem.view = not ConfigItem.view
                self.update_gui()
            elif k == 'KEY_LEFT':
                # For future use
                pass
            elif k == 'KEY_RIGHT':
                # For future use
                pass
            elif k == 'KEY_BACKSPACE':
                # For future use
                pass
            elif k == 'kUP5': # CTRL+UP_ARROW
                # For future use
                pass
            elif k == 'kDN5': # CTRL+DOWN_ARROW
                # For future use
                pass
            elif selected and k in [chr(x) for x in range(ord('a'), ord('z')+1)]: # a-z
                # Proceeds to the next item the name of which begins with given letter

                i = (self.selectables.index(self.selection) + 1) % len(self.selectables)
                first_letters = self.first_letters[i:] + self.first_letters[:i]

                try:
                    f = (first_letters.index(k) + i) % len(first_letters)
                except ValueError: # letter not found
                    f = -1

                if f >= 0:
                    self.selection = self.selectables[f]
                    self.update_gui()

    def get_cmd(self):
        """Returns command which is to be executed
        """
        return self.command

    def read_config(self):
        """Reads config file
        """
        self.items = []
        self.selectables = []
        self.groups = []
        self.first_letters = []
        self.selection = -1

        if os.path.isfile(self.config_path):
            f_config = open(self.config_path, 'r')
            for raw_line in f_config:
                line = raw_line.strip()
                if len(line):
                    if line[0] == '#':
                        self.items.append(Comment(line[1:]))
                    else:
                        sep = line.find(' ')
                        if sep < 0:
                            alias = line
                            command = line
                        else:
                            alias = line[:sep].strip()
                            command = line[sep:].strip()

                        self.items.append(Command(alias, command))
                else:
                    self.items.append(Empty())

            f_config.close()

            self.selectables = [i for (i, item) in enumerate(self.items) if item.selectable]
            self.groups = [x for x,y in zip(self.selectables, [-2] + self.selectables[:-1]) if x-y>1]
            self.first_letters = [self.items[i].alias[0].lower() for i in self.selectables]

        if len(self.selectables):
            self.selection = self.selectables[0]

    def update_gui(self):
        """Updates GUI with displayable items form config file
        """
        self.stdscr.clear()

        for (i, item) in enumerate(self.items):
            if i == self.selection:
                self.stdscr.attron(curses.A_STANDOUT) # Highlighting ON

            if item.bold:
                self.stdscr.attron(curses.A_BOLD)     # Bold ON
            
            self.stdscr.addstr(i, 0, str(item))
            
            self.stdscr.attroff(curses.A_STANDOUT)    # Highlighting OFF
            self.stdscr.attroff(curses.A_BOLD)        # Bold OFF

        self.stdscr.refresh()

    def find_cmd(self, alias):
        """Searches for the command by it's alias
        """
        try:
            selectable_items = [item for item in self.items if item.selectable]
            i = [item.alias for item in selectable_items].index(alias)
        except ValueError, e:
            raise AliasNotFound(alias)

        self.command = selectable_items[i].cmd

    def list_aliases(self):
        """Prints all the aliases from the config file
        """
        aliases = list(set([item.alias for item in self.items if item.selectable])) # set does unique()
        aliases.sort()
        for alias in aliases:
            print alias

if __name__ == "__main__":

    description = \
    """
    Gives quick access to the commands defined in advance.
    Each command can have own alias. Set of commands and aliases is defined
    in .quickcmd file in your home directory.

    Key bindings:
    --------------
    CTRL+C                        - close application
    RETURN                        - close application and execute selected command
    ARROW_UP                      - select previous command
    ARROW_DOWN                    - select next command
    PAGE_UP or SHIFT+ARROW_UP     - move selection to the previous group
    PAGE_DOWN or SHIFT+ARROW_DOWN - move selection to the next group
    TAB                           - edit configuration file
    SPACE                         - switch view between aliases and commands
    a-z                           - move selestion to the next command, alias of
                                    witch begins with the given letter
    """

    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('alias', nargs='?', help='Exexute command specyfied by alias')
    parser.add_argument('--list', '-l', action='store_true', help='List available aliases')
    args = parser.parse_args()

    try:
        qc = Quickcmd()
        if args.list:
            qc.list_aliases()
        else:
            if args.alias == None:
                qc.display_gui()
            else:
                qc.find_cmd(args.alias)

            subprocess.call(qc.get_cmd(), shell=True)

    except Exception, e:
        print 'ERROR: ' + str(e)
        exit(1)


