#!/usr/bin/env python
# -*- coding: utf-8 -*-

import curses
import subprocess
import os
from os.path import expanduser
home = expanduser("~")

class Quickcmd:
    PAGE_SIZE = 5

    def __init__(self, stdscr):
        self.config_path = ''
        self.view = 0
        self.selection = -1
        self.items = []
        self.stdscr = stdscr
        self.command = ''

        self.setup_config()
        self.setup_curses()
        self.read_file()
        self.display()
        self.wait_for_user()

    def setup_config(self):
        self.config_path = os.path.expanduser('~' + os.path.sep + '.quickcmd')
        if not os.path.isfile(self.config_path):
            self.config_path = 'config'

    def disable_curses(self):
        self.stdscr.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()

    def enable_curses(self):
        self.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        self.stdscr.keypad(1)
        try:
            curses.start_color()
        except:
            pass

        self.setup_curses()

    def setup_curses(self):
        curses.curs_set(0)

    def wait_for_user(self):

        while(True):
            k = self.stdscr.getkey()
            if k == '\n': # RETURN
                self.command = self.items[self.selection][1]
                break
            elif k == 'KEY_UP':
                self.selection = max(self.selection-1, 0)
                self.display()
            elif k == 'KEY_DOWN':
                self.selection = min(self.selection+1, len(self.items)-1)
                self.display()
            elif k == 'KEY_PPAGE': # PAGE UP
                self.selection = max(self.selection-self.PAGE_SIZE, 0)
                self.display()
            elif k == 'KEY_NPAGE': # PAGE DOWN
                self.selection = min(self.selection+self.PAGE_SIZE, len(self.items)-1)
                self.display()
            elif k == 'KEY_LEFT':
                pass
            elif k == 'KEY_RIGHT':
                pass
            elif k == 'e':
                self.disable_curses()
                os.system('vi +' + str(self.selection+1) + ' ' + self.config_path)
                self.enable_curses()
                self.read_file()
                self.display()
            elif k == ' ': # SPACE
                pass
            elif k == '\t': # TAB
                self.view = (self.view + 1) % 2
                self.display()
            elif k == 'h':
                pass
            elif k == 'q':
                break
            elif k == 'kUP5': # CTRL + UP_ARROW
                pass
            elif k == 'kDN5': # CTRL + DOWN_ARROW
                pass


    def read_file(self):
        self.items = []
        f_commands = open(self.config_path, 'r')
        for line in f_commands:
            sep = line.find(' ')
            alias = line[:sep].strip()
            command = line[sep:].strip()
            self.items.append((alias, command))

        f_commands.close()

        if len(self.items):
            self.selection = 0
        else:
            self.selection = -1

    def display(self):
        self.stdscr.clear()
        self.stdscr.refresh()

        i = 0
        for item in self.items:
            if i == self.selection:
                self.stdscr.attron(curses.A_STANDOUT);
            else:
                self.stdscr.attroff(curses.A_STANDOUT);

            self.stdscr.addstr(i, 0, item[self.view])

            i += 1

command = ''
def main(stdscr):
    qc = Quickcmd(stdscr)
    global command
    command = qc.command

if __name__ == "__main__":    
    curses.wrapper(main)
    subprocess.call(command, shell=True)

